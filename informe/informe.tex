%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definición del tipo de documento.                                           %
% Posibles tipos de papel: a4paper, letterpaper, legalpapper                  %
% Posibles tamaños de letra: 10pt, 11pt, 12pt                                 %
% Posibles clases de documentos: article, report, book, slides                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,10pt]{article}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Los paquetes permiten ampliar las capacidades de LaTeX.                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Paquete para inclusión de gráficos.
\usepackage{graphicx}

% Paquete para definir la codificación del conjunto de caracteres usado
% (latin1 es ISO 8859-1).
\usepackage[latin1]{inputenc}

% Paquete para definir el idioma usado.
\usepackage[spanish]{babel}


% Título principal del documento.
\title{		\textbf{Trabajo Práctico 2: Data path y pipeline}}

% Información sobre los autores.
\author{	José Ignacio Sbruzzi, \textit{Padrón Nro. 97.452}                     \\
            \texttt{ jose\_sbruzzi@hotmail.com }                                              \\
            Leandro Huemul Desuque, \textit{Padrón Nro. 95.836}                     \\
            \texttt{ desuqueleandro@gmail.com }                                              \\[2.5ex]
            \normalsize{2do. Cuatrimestre de 2016}                       \\
            \normalsize{66.20 Organización de Computadoras}                             \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
       }
\date{}



\begin{document}

% Inserta el título.
\maketitle

% Quita el número en la primer página.
\thispagestyle{empty}

% Resumen
\begin{abstract}
Se introdujeron modificaciones sobre datapaths para agregar ciertas 
funcionalidades a los mismos. El objetivo del trabajo es la práctica 
y el aprendizaje del funcionamiento del datapath.
\end{abstract}

\section{Introducción}
El objetivo del presente trabajo es introducir una serie de 
modificaciones a datapaths que vienen con el software DrMips. De esta 
forma, nos familiarizamos con los conceptos fundamentales de la
Organización de Computadoras.
%MIPS ES....
%LOS DATAPATHS SON...
% \textit{66.20 Organización de Computadoras} ESTO PONE TEXTO EN CURSIVA

\section{Desarrollo}

%------------------------------------------------------------------------------------

\subsection{Modificación del DP monociclo}
La modificación introducida fue una nueva instrucción denominada "load 
byte unsigned" (mnemónico lbu), que en vez de cargar un word como lw, 
carga un byte, y no hace extensión de signo: los bits a la izquierda del
último son simpre 0.
\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/lbu_monocycle.eps}
\end{center}
\caption{Estado final del datapath monociclo} \label{fig:stack}
\end{figure}

\subsubsection{Procedimiento de la modificación }
Luego de notar que incluso al recibir direcciones desalineadas la memoria
carga una palabra alineada (es decir, por ejemplo, las direcciones 0, 1, 
2 y 3 hacen que se carge la palabra en la dirección 0), se decidio hacer
que lbu funcionara exactamente igual que lw, pero removiendo 3 bytes, 
haciendo parecer de esta manera que se carga un solo byte.

Para esto, se agregó una señal a la unidad de control llamada "cortar".
La señal impacta el sistema por medio de un multiplexor que define si se
guardará en el register file la palabra obtenida de memoria o una versión
modificada que mantiene un sólo byte. El word modificado se calcula 
incluso si la señal "cortar" es 0.

La modificación del word es llevada a cabo por medio de un 
\textit{Distributor} que divide el word en sus 4 bytes. Luego, por medio 
de un multiplexor se realiza la elección de uno de esos 4 bytes. 
Finalmente, el byte seleccionado se concatena a 24 ceros, quedando así
el byte seleccionado en la parte menos significativa del word.


\subsubsection{Pruebas}
A continuación se muestra el código assembler utilizado como prueba. El
CPU pasa la prueba si en el registro t0 queda el valor 0x000000aa, el 
registro t2 queda en 0x000000bb, el t3 en 0x000000cc y el t4 en 
0x000000dd.

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/lbu_monocycle_prueba.eps}
\end{center}
\caption{Prueba utilizada para verificar el correcto funcionamiento de la modificación} \label{fig:stack}
\end{figure}
%\subsubsection{\texttt{Especificaciones}}

%\begin{figure}[!htp]
%\begin{center}
%\includegraphics[width=0.4\textwidth]{imagenes/imagenStack.eps}
%\end{center}
%\caption{Stack de la función vecinos} \label{fig:stack}
%\end{figure}
%
%Se reservaron 12 bytes para el área de SRA, 4 bytes para salvar el registro \textit{ra} (no era necesario ya que en ningun momento los saltos para realizar comparaciones modifican el ra, de cualquier forma y como buena práctica, se guardó su valor), 4 bytes para salvar el registro \textit{gp} y 4 bytes para salvar el registro \textit{fp}.
%
%Al tratarse de una matriz cuadrada (MxM), el cálculo de la posición relativa se hizo utilizando solo el ancho. Se pasó el alto para cumplir con la firma pedida por el trabajo práctico y para contemplar posibles mejoras u optimizaciones a futuro (por ejemplo, que se permitan matrices de MxN). Se reservaron 16 bytes en concepto de ABA, respetando ABI. ~\ref{fig:stack}.
%
%\subsection{Dificultades}
%La construcción de una imagen en formato PBM presentó algunas dificultades ya que se usó PBM en vez de plain PBM, y en la descripción del formato PBM no había ejemplos de archivos PBM (sí los había de plain PBM). Un punto relativamente problemático del formato PBM es que cada pixel está asociado a un bit. Para evitar esta dificultad, se decidió que cada celda correspondería a un cuadrado de 8x8 pixeles, simplificando el fragmento del programa que guarda las imágenes.
%
%\section{Compilación}
%En lugar de utilizar un \textit{makefile} se optó por programar un script (\textit{hacer.sh}) para dicha tarea, que cumple el mismo objetivo: ejecutar las instrucciones adecuadas de compilacion. 
%
%Se compilan de manera individual cada uno de los archivos fuente de extension \textit{c} y \textit{S} a traves del ejecutable \textit{gcc}.
%
%Los argumentos utilizados para la compilación son los siguientes:
%
%\begin{description}
%\item[-c] Compila el código fuente pero no corre el linker. Genera el código objeto.
%
%\item[-o] Especifica el archivo de salida (ya sea un archivo objeto, ejecutable, ensamblado).
%
%\item[-Wall] Activa los mensajes de warning.
%
%\item[-I] Agrega el directorio especificado a la lista de directorios buscados para los archivos header
%\end{description}

%-------------------------------------------------------------------------------------
\subsection{Modificación del DP pipeline: jal}

Se decidió agregar la instrucción jal antes de la bgezal para aprovechar 
el hardware añadido. Inicialmente se notó que el los branches se 
resuelven en la etapa MEM: es allí donde se modifica el PC. El guardado
de la dirección de retorno en el registro ra puede realizarse en la etapa
WB, ya que jal -tal como hace beq- "flushea" todos los registros 
interetapa, con lo cual al ejecutarse el WB del jal, la instrucción que
sigue estará en la etapa IF.

Con el objetivo de hacer la menor cantidad de modificaciones posibles, 
no se cambia la condición del salto: se siguen comparando dos registros,
solo que esta vez siempre se comparan los registros zero. Así, 
\textit{jal offset} equivale a \textit{beq zero, zero, offset} con la 
única diferencia de que se guarda PC+4 en RA.

Entonces, se agregó una señal "GuardarPC" a la unidad de control, la 
cual se guarda en los registros interetapa siguientes a ID. Además se
agregó NewPC (presente en ID/EX) a a los registros EX/MEM y MEM/WB.

Se Agregan también dos multiplexores en la etapa WB controlados por la
señal "GuardarPC": uno permite fijar la señal WriteAddress en 31 
(correspondiente a RA) y otro que permite fijar WriteData en NewPC.

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/jal_circuito.eps}
\end{center}
\caption{Datapath pipeline con jal} \label{fig:stack}
\end{figure}

\subsubsection{pruebas}

La prueba utilizada se expone a continuación. Si es exitosa, t1 termina
en 0, t0 termina en 1 y ra en 0c.

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/prueba_jal.eps}
\end{center}
\caption{Datapath pipeline con jal} \label{fig:stack}
\end{figure}

%----------------------------------------------------------------------------------

\subsection{Modificación del DP pipeline: bgeal y bgezal}

Una tarea solicitada fue la implementación de una instrucción BGEZAL. 
En vez de implementar bgezal, se decidió implementar bgeal, y hacer que
bgezal sea una pseudoinstrucción. La pseudoinstrucción se traduce
como una única instrucción (se cambia uno de los argumentos por el 
registro zero), con lo que no hay pérdidas de velocidad y se gana
versatilidad.

La compuerta AND de la etapa MEM reúne la información proveniente de las
señales Branch (proveniente de la unidad de control, fijada en la 
instrucción) y Zero (proveniente de la ALU, es 1 si el resultado de la 
ALU es 0). La ALU implementa la operación slt, con lo cual, por medio de
modificaciones de software a partir de la instrucción JAL se puede 
obtener BGEAL. Se aprovechó que slt deja el bit Zero en 1 si la 
condición "mayor o igual" se cumple (pero no "menor estricto").

\subsubsection{modificación bgeal}
Las modificaciones respecto de JAL, así, no se hicieron sobre el 
archivo que describe el hardware (.cpu) sino sobre el que describe el 
software (.set). Se tomó la línea de la sección "instructions" que 
describe beq y sólo se reemplazaron el opcode (por uno nuevo, distinto
del de JAL) y el nombre mismo de la instrucción.

En la sección "control" se copió la línea que corresponde al beq, pero
se cambió el valor de RegWrite y GuardarPC a 1 (tal como se había hecho 
para JAL) y se asignó un nuevo ALUop. El nuevo ALUop se hizo 
corresponder con la operación slt en la sección "alu" del mismo archivo.

Luego de hacer pruebas se detectó que el registro RA se guardaba 
siempre, se dé o no el salto, con lo que se hizo necesario almacenar el
valor de salida del componente AndBranch (que registra si realmente se 
llevó a cabo el branch) en el registro interetapa MEM/WB, y luego usar 
una compuerta AND y un multiplexor para filtrar el valor de la señal
RegWrite.

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/bgeal_circuito.eps}
\end{center}
\caption{Datapath pipeline con las modificaciones necesarias para bgeal} \label{fig:stack}
\end{figure}

\subsubsection{modificación bgezal}
Se agregó la pseudoinstrucción bgezal, que es bgeal pero con su segundo 
argumento en el registro 0.

\subsubsection{pruebas}
Se utilizaron tres pruebas, una de las cuales está representada a 
continuación. Las otras dos son variantes en las que se cambia el -5 por
un número positivo y por 0. De ser un número positivo o 0, al final de la 
ejecución RA es 0c y t0 es aaa, de lo contrario, RA es 0 y t0 es bbb.

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/prueba_bgeal.eps}
\end{center}
\caption{Prueba de bgezal.} \label{fig:stack}
\end{figure}

\subsubsection{mejoras posibles}
Una vez implementada bgeal, se podría implementar jal como una 
pseudoinstrucción y de esta manera se reduciría el número de 
instrucciones que implementa el datapath.

%----------------------------------------------------------------------------

\subsection{Modificación del DP pipeline: sb}
La instrucción sb (store byte) almacena el byte más bajo del registro 
pasado en memoria. El problema más importante que presenta esta 
instrucción es el hecho de que DrMips maneja la memoria de a words: es
imposible guardar o cargar un único byte. Así, la instrucción debería 
cargar un word, superponerle el byte a guardar, y luego guardar ese word
a memoria.
Otro problema es que es imposible guardar y cargar datos a memoria en el
mismo ciclo, con lo que la instrucción debería ocupar la etapa MEM 
durante dos ciclos. Esto va en contra de la idea central del pipeline, 
con lo que se hace necesario implementar sb como una pseudoinstrucción
que tenga al menos dos instrucciones: una de carga y otra de 
almacenamiento. Las operaciones intermedias en las que se transforma el
word también son complicadas, ya que requieren la aplicación de varias
máscaras de bits.

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/implementacion_sb.eps}
\end{center}
\caption{Implementación de sb como macro} \label{fig:stack}
\end{figure}
	
La idea es remover el enmascarado de la palabra cargada: construir
una instrucción que cargue la palabra entera, pero que ponga en 0 el 
byte que luego se va a escribir. La instrucción se llamaría lwob (load
without byte).

Se hace también necesario implementar sllv y srlv. Disponer de un solo
registro auxiliar supone un problema muy grave, ya que se hace necesario
casi duplicar la cantidad de instrucciones necesarias.

Es imposible generar la pseudoinstrucción sin lwob porque todos los
cómputos de la máscara requerirían al menos un registro auxiliar más.

Una mejora posible a la implementación propuesta es agregar sll, con lo 
que se reduciría en 4 el número de instrucciones.

\subsubsection{Implementación de sllv y srlv}
La ALU ya soporta las operaciones slr y sll, con lo que sólo es
necesario modificar los archivos .set.
Se agregaron las instrucciones en la sección "instructions", agregando 
nuevas líneas a partir de las de add. Se les asignaron campos "func" 
nuevos, y se hizo la relación entre esos campos y las operaciones
correspondientes en la sección "alu".

\subsubsection{Implementación de lwob}
Se agregó a la unidad de control la señal lwob, que se almacena en los
tres registros interetapa siguientes. En la etapa de memoria se agregó
un circuito combinacional que a partir de los dos bits más bajos del 
campo "Result", que indica la dirección de donde provienen los datos,
calcula el word final removiéndole el byte correspondiente. Finalmente,
mediante un multiplexor al que ingresa la señal lwob se elige si usar el
word calculado o el usual.

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/implementacion_lwob.eps}
\end{center}
\caption{Implementación de lwob en el datapath} \label{fig:stack}
\end{figure}

\subsubsubsection{Prueba de lwob}

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/prueba_lwob.eps}
\end{center}
\caption{Prueba de lwob} \label{fig:stack}
\end{figure}

La prueba, de ser exitosa, deja t1 en 0x11223300, t2 en 0x11220044, t3
en 0x11003344, y t4 en 0x00223344. Nótese que en este caso se utilizó un
endianness distinto del correspondiente al lbu. Se considera esto válido
porque, al ser distintos datapath, no hay conflictos con el endianness
de las instrucciones.

\subsubsection{Implementación de sb}
Se modificó la macro mostrada más arriba y se incluyó la 
pseudoinstrucción en el archivo .set correspondiente. Como el DrMips no
está preparado para pseudoinstrucciones de la forma 
\textit{sb rs, Imm(rt)}, se tuve que usar la forma 
\textit{sb rs, rt, Imm}.

\subsubsection{Prueba de sb}

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=15cm\textwidth]{imagenes/prueba_sb.eps}
\end{center}
\caption{Prueba de sb} \label{fig:stack}
\end{figure}

El resultado de la prueba es:
t1 debe terminar en 0x88
t2 en 55223344
t3 en 55663344
t4 en 55667744
t5 en 55667788.

Se probó cada caso por separado para encontrar todos los errores de la
pseudoinstrucción. Una limitación que se encontró es que la
pseudoinstrucción no funciona si se le pasa el registro zero como uno de
sus argumentos, ya que es necesario escribir sobre él.

\section{Resultados}
Además de las modificaciones y los resultados de las pruebas, ambos ya
expuestos, en todos los casos puede notarse que implementar la 
instrucción en el datapath disminuye muchísimo la cantidad de
instrucciones en contraste con la opción de crear una pseudoinstrucción.

\section{Conclusiones}
Al manejar el datapath y modificarlo, se conoció en detalle su 
funcionamiento, y se produjo una familiarización con el mismo que no
hubiera sido posible de haberse estudiado únicamente como algo teórico.

Una dificultad muy grande que se tuve en el desarrollo del trabajo fue
el hecho de que el software no tiene una interfaz gráfica para modificar
los circuitos. Esto incluso influenció en cierta medida algunas 
decisiones de diseño.

Resulta compulsorio el desarrollo de una herramienta que permita editar
los archivos .cpu más facilmente.


% Citas bibliográficas.
\begin{thebibliography}{99}

\bibitem{Conway} Gardner, Martin. ``Mathematical Games - The fantastic combinations of John Conway's new solitaire game 'life` '' Scientific America, 223. pp. 120-123. ISBN 0-89454-001-7. Archivado del original en: https://ddi.cs.uni-potsdam.de/HyFISCH/Produzieren/lis\_projekt/proj\_gamelife/ConwaySci-entificAmerican.htm

Consultado en septiembre 2016.

\bibitem{GXemul} Sitio web de GXemul http://gxemul.sourceforge.net/

Consultado en septiembre 2016.

\end{thebibliography}

\end{document}
